import XCTest
@testable import JWWCore

final class DecodingErrorDebugExtensionTests: XCTestCase {
    /// Validate we properly parse out a `.dataCorrupted` error generated by invalid JSON.
    func testReportingInvalidJSONError() throws {
        let json = """
        {
            "first_name": "Steve",
            "last_name": Case",
            "age": 64
        }
        """
#if swift(>=5.5)
        let expectedMessage = "Data corrupted. The given data was not valid JSON. Invalid value around line 3, column 17."
#else
        let expectedMessage = "Data corrupted. The given data was not valid JSON. Invalid value around character 46."
#endif

        try assertDecodingErrorMessageEquals(json, expectedMessage)
    }

    /// Validate we properly parse out a `.keyNotFound` error.
    func testReportingMissingKeyJSONErrorWithEmptyPath() throws {
        let json = """
        {
            "first_name": "Steve",
            "age": 64
        }
        """
        let expectedMessage = "Key not found: 'last_name'."

        try assertDecodingErrorMessageEquals(json, expectedMessage)
    }

    /// Validate we properly parse out a `.typeMismatch` error.
    func testTypeMismatchError() throws {
        let json = """
        {
            "first_name": "Steve",
            "last_name": "Case",
            "age": "64"
        }
        """

        let expectedMessage = "Type mismatch. Expected to decode Int but found a string/data instead. key path: age"

        try assertDecodingErrorMessageEquals(json, expectedMessage)
    }

    /// Validate we properly parse out a `.valueNotFound` error.
    func testValueNotFoundError() throws {
        let json = """
        {
            "first_name": "Steve",
            "last_name": null,
            "age": 64
        }
        """

        let expectedMessage = "Value not found at 'last_name'. Expected String value but found null instead."

        try assertDecodingErrorMessageEquals(json, expectedMessage)
    }

    // MARK: Private / Convenience
    // ====================================
    // Private / Convenience
    // ====================================

    private func assertDecodingErrorMessageEquals(_ json: String, _ expectedMessage: String, file: String = #filePath, line: Int = #line) throws {
        let data = try XCTUnwrap(json.data(using: .utf8))

        var decodingError: DecodingError?
        XCTAssertThrowsError(try JSONDecoder().decode(CodableFixture.self, from: data)) { error in
            guard let error = error as? DecodingError else {
                XCTFail("Error returned was not a DecodingError")
                return
            }

            decodingError = error
        }

        let unwrappedError = try XCTUnwrap(decodingError)
        let result = String(reflecting: unwrappedError)

        XCTAssertEqual(result, expectedMessage)
    }
}

/// Fixture that can be used for stubbing in payloads for various testing purposes.
private struct CodableFixture: Codable {
    let firstName: String
    let lastName: String
    let age: Int

    enum CodingKeys: String, CodingKey {
        case firstName = "first_name"
        case lastName = "last_name"
        case age
    }

    static func fixture() -> CodableFixture {
        return CodableFixture(firstName: "Steve", lastName: "Case", age: 60)
    }
}

private struct People: Codable {
    let people: [CodableFixture]
}
